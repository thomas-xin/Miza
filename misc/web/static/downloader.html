<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>All-Purpose Media Downloader</title>
	<link href='https://fonts.googleapis.com/css?family=Agbalumo' rel='stylesheet'>
	<style>
body {
	font-family: Agbalumo, cursive, sans-serif;
	margin-top: 5vh;
	padding: 0;
	position: relative;
	display: grid;
	align-items: start;
	justify-content: center;
	background-color: #000000;
	color: white;
}
.container {
	margin: 4px;
	display: flex;
	flex-wrap: wrap;
	align-items: center;
	justify-content: center;
	max-width: 90vw;
	background-color: #001f3f;
	padding: 16px;
	border-radius: 0px 20px 0px 20px;
	border: solid 2px #00ffff;
}
.entry {
	width: 320px;
	margin: 4px;
	display: grid;
	place-items: center;
	background-color: #003f3f;
	border: solid 2px #00ff7f;
	padding: 12px;
	border-radius: 8px;
}
h1, h2 {
	margin: 0 0 8px 0;
}
h3 {
	margin: 4px 0 0 0;
	color: #00ffff;
}
input {
	background-color: #000000;
	color: #bf7fff;
	accent-color: #ff0000;
}
label {
	color: #bf7fff;
}
button {
	margin-top: 8px;
	position: relative;
	left: 50%;
	transform: translate(-50%, 0px);
	padding: 10px 15px;
	border: none;
	background-color: #0056b3;
	color: #ffffff;
	border-radius: 5px;
	cursor: pointer;
}
button:hover {
	background-color: #007bff;
}
#fileInfo {
	margin-top: 20px;
}
a {
	color: #007bff;
	text-decoration: none;
}
a:hover {
	text-decoration: underline;
}
.progress-container {
	width: 90%;
	height: 8px;
	background-color: #000000;
	border-radius: 10px;
	position: relative;
	margin: 8px;
}
.progress-bar {
	height: 100%;
	background-color: #7f7f7f;
	border-radius: 4px;
	position: absolute;
	width: 0%;
}
.progress-thumb {
	width: 12px;
	height: 12px;
	background-color: #ffffff;
	border-radius: 50%;
	position: absolute;
	top: 50%;
	transform: translate(-50%, -50%);
	cursor: pointer;
}
	</style>
</head>
<body>
	<div class="container">
		<div>
			<h1>Download Media</h1>
			<h3>Name or URL</h3>
			<input type="text" id="query" style="min-width:320px; width:60vw" oninput="debouncedSearch()" onchange="debouncedSearch()" value="" required>
			<h3>Format</h3>
			
			<input type="radio" id="mp4" name="output-format" value="mp4" checked><label for="mp4">mp4</label><br />
			<input type="radio" id="webm" name="output-format" value="webm"><label for="webm">webm</label><br />
			<input type="radio" id="opus" name="output-format" value="opus"><label for="opus">opus (audio)</label><br />
			<input type="radio" id="ogg" name="output-format" value="ogg"><label for="ogg">ogg (audio)</label><br />
			<input type="radio" id="mp3" name="output-format" value="mp3"><label for="mp3">mp3 (audio)</label>
		</div>
	</div>
	<div id="previews" class="container" style="display:none">
	</div>
	<button id="submit" style="width:60%; display:none" onclick="download()">Download</button>
</body>
<script>
function timeDisp(s, rounded = true) {
	"Returns a representation of a time interval using days:hours:minutes:seconds.";
	if (!isFinite(s)) {
		return String(s);
	}
	if (rounded) {
		s = Math.round(s);
	}
	let output = String(s % 60);
	if (output.length < 2) {
		output = "0" + output;
	}
	if (s >= 60) {
		let temp = String(Math.floor(s / 60) % 60);
		if (temp.length < 2 && s >= 3600) {
			temp = "0" + temp;
		}
		output = temp + ":" + output;
		if (s >= 3600) {
			temp = String(Math.floor(s / 3600) % 24);
			if (temp.length < 2 && s >= 86400) {
				temp = "0" + temp;
			}
			output = temp + ":" + output;
			if (s >= 86400) {
				output = String(Math.floor(s / 86400)) + ":" + output;
			}
		}
	} else {
		output = "0:" + output;
	}
	return output;
}
function rgbToHsl(r, g, b) {
	r /= 255;
	g /= 255;
	b /= 255;
	const max = Math.max(r, g, b);
	const min = Math.min(r, g, b);
	let h, s, l = (max + min) / 2;
	if (max === min) {
		h = s = 0;
	} else {
		const d = max - min;
		s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
		switch (max) {
			case r:
				h = (g - b) / d + (g < b ? 6 : 0);
				break;
			case g:
				h = (b - r) / d + 2;
				break;
			case b:
				h = (r - g) / d + 4;
				break;
		}
		h /= 6;
	}
	return [h * 360, s * 100, l * 100];
}
function isLoaded(image) {
	return image.complete && image.naturalHeight !== 0;
}
function debounce(func, delay) {
	let timeoutId;
	let lastSent = Date.now();
	return function(...args) {
		if (timeoutId) {
			clearTimeout(timeoutId);
		}
		const currentTime = Date.now();
		const delta = currentTime - lastSent;
		lastSent = currentTime;
		const usedDelay = Math.min(delta, delay) + delay;
		timeoutId = setTimeout(() => {
			func.apply(this, args);
		}, usedDelay);
	};
}
var lastSearch = "";
function updateSearched() {
	previews = document.getElementById("previews");
	submit = document.getElementById("submit");
	query = document.getElementById("query").value;
	if (query == lastSearch) return;
	lastSearch = query;
	previews.style.display = "none";
	// console.log(query);
	if (!query) return;
	previews.textContent = "Loading...";
	previews.style.display = "block";
	component = encodeURIComponent(query);
	fetch(`/ytdl?q=${component}`).then((response) => response.json()).then((data) => {
		previews.style.display = "none";
		previews.textContent = "";
		// console.log(data);
		data.forEach((e, i) => {
			const preview = document.createElement("div");
			name = e.name;
			preview.name = name;
			preview.className = "entry";
			title = document.createElement("p");
			title.style.margin = "0";
			check = document.createElement("input");
			check.type = "checkbox";
			check.checked = !i || query.startsWith("https://");
			title.appendChild(check);
			href = document.createElement("a");
			href.textContent = name;
			href.href = e.url;
			title.appendChild(href);
			preview.appendChild(title);
			const icon = document.createElement("img");
			icon.width = 320;
			icon.src = e.icon;
			preview.appendChild(icon);
			let dur;
			if (e.duration) {
				preview.duration = e.duration;
				dur = document.createElement("span");
				dur.style.lineHeight = "8px";
				dur.textContent = timeDisp(preview.duration);
				preview.appendChild(dur);
			}
			component = encodeURIComponent(e.icon);
			fetch(`/mean_colour?url=${component}`).then((response) => response.json()).then((data) => {
				[r, g, b] = data.colour;
				[h, s, l] = rgbToHsl(r, g, b);
				preview.animate(
					[
						{ backgroundColor: "#003f3f", border: "solid 2px #00ff7f" },
						{ backgroundColor: `hsl(${h},${s}%,25%)`, border: `solid 2px hsl(${h},${s}%,50%)` }
					],
					{ duration: 500, easing: "linear", fill: "forwards" },
				);
				preview.loadTrimmer = () => {
					s2 = 100 - (100 - s) / 2;
					if (!e["duration"]) return;
					const progressContainer = document.createElement("div");
					progressContainer.className = "progress-container";
					progressContainer.style.backgroundColor = `hsl(${h},${s2}%,12.5%)`;
					const progressBar = document.createElement("div");
					progressBar.className = "progress-bar";
					progressBar.style.backgroundColor = `hsl(${h},${s2}%,50%)`;
					const progressStart = document.createElement("div");
					progressStart.className = "progress-thumb";
					progressStart.style.backgroundColor = `hsl(${h},${s2}%,75%)`;
					const progressEnd = document.createElement("div");
					progressEnd.className = "progress-thumb";
					progressEnd.style.backgroundColor = `hsl(${h},${s2}%,75%)`;

					preview.updateProgress = () => {
						if (preview.startP > preview.endP) {
							[preview.startP, preview.endP] = [preview.endP, preview.startP];
						} else if (preview.startP > preview.endP) {
							if (preview.endP >= 100) preview.startP -= 0.01;
							else preview.endP += 0.01;
						}
						preview.start = preview.startP * preview.duration / 100;
						preview.end = preview.endP * preview.duration / 100;
						length = preview.endP - preview.startP;
						progressStart.style.left = `${preview.startP}%`;
						progressBar.style.left = `${preview.startP}%`;
						progressBar.style.width = `${length}%`;
						progressEnd.style.left = `${preview.endP}%`;
						if (preview.startP != 0 || preview.endP != 100) {
							dur.textContent = timeDisp(preview.start) + "-" + timeDisp(preview.end) + "/" + timeDisp(preview.duration);
						} else {
							dur.textContent = timeDisp(preview.duration);
						}
					}
					preview.startP = 0;
					preview.endP = 100;

					preview.calculateProgress = (event) => {
						rect = progressContainer.getBoundingClientRect();
						offsetX = Math.min(Math.max(event.clientX - rect.left, 0), rect.width);
						progress = (offsetX / rect.width) * 100;
						return progress;
					}
					progressContainer.addEventListener('mousedown', (event) => {
						event.preventDefault();
						progress = preview.calculateProgress(event);
						if (Math.abs(progress - preview.startP) < Math.abs(progress - preview.endP)) {
							const progressStartDrag = (event) => {
								if (progressStart.dragging) {
									const progress = preview.calculateProgress(event);
									preview.startP = progress;
									preview.updateProgress();
								}
							}
							document.addEventListener('mousemove', progressStartDrag);
							document.addEventListener('mouseup', () => {
								progressStart.style.backgroundColor = `hsl(${h},${s2}%,75%)`;
								progressStart.dragging = false;
								document.removeEventListener('mousemove', progressStartDrag);
							}, { once: true });
							progressStart.style.backgroundColor = "#ffffff";
							progressStart.dragging = true;
							preview.startP = progress;
							preview.updateProgress();
						} else {
							const progressEndDrag = (event) => {
								if (progressEnd.dragging) {
									const progress = preview.calculateProgress(event);
									preview.endP = progress;
									preview.updateProgress();
								}
							}
							document.addEventListener('mousemove', progressEndDrag);
							document.addEventListener('mouseup', () => {
								progressEnd.style.backgroundColor = `hsl(${h},${s2}%,75%)`;
								progressEnd.dragging = false;
								document.removeEventListener('mousemove', progressEndDrag);
							}, { once: true });
							progressEnd.style.backgroundColor = "#ffffff";
							progressEnd.dragging = true;
							preview.endP = progress;
							preview.updateProgress();
						}
					});
					progressContainer.appendChild(progressBar);
					progressContainer.appendChild(progressStart);
					progressContainer.appendChild(progressEnd);
					preview.insertBefore(progressContainer, dur);

					preview.updateProgress();
				}
				if (isLoaded(icon)) {
					preview.loadTrimmer();
				} else {
					icon.onload = preview.loadTrimmer;
				}
			});
			previews.appendChild(preview);
		});
		previews.style.display = data ? "flex" : "none";
		submit.style.display = data ? "block" : "none";
	});
}
const debouncedSearch = debounce(updateSearched, 500);
document.getElementById("query").value = lastSearch;
function download() {
	submit = document.getElementById("submit");
	submit.textContent = "Loading...";
	submit.disabled = true;
	Array.from(document.getElementById("previews").children).forEach((preview, i) => {
		check = preview.children[0].children[0];
		if (!check.checked) return;
		fmt = document.querySelector('input[name="output-format"]:checked').value;
		a = document.createElement("a");
		a.href = "/ytdl?d=" + encodeURIComponent(preview.children[0].children[1].href) + "&fmt=" + fmt;
		if (preview.start) {
			a.href += "&start=" + preview.start;
		}
		if (preview.end && preview.end != preview.duration) {
			a.href += "&end=" + preview.end;
		}
		a.click();
	});
	setTimeout(() => {
		submit.disabled = false;
		submit.textContent = "Download";
	}, 3000);
}
</script>
</html>